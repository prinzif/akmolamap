<!-- frontend/ndvi.html -->


<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>NDVI –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ - –ê–∫–º–æ–ª–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å</title>

  <!-- Favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üå±</text></svg>">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- –ó–ê–ì–†–£–ó–ß–ò–ö –ü–õ–ê–ì–ò–ù–û–í –ü–û–°–õ–ï Leaflet (–¢–û–õ–¨–ö–û UMD —Å CDN) -->
  <script>
    (function () {
      function load(src) {
        return new Promise((resolve) => {
          const s = document.createElement('script');
          s.src = src;
          s.async = false;              // –≤–∞–∂–µ–Ω –ø–æ—Ä—è–¥–æ–∫
          s.onload = () => resolve(true);
          s.onerror = () => resolve(false);
          document.head.appendChild(s);
        });
      }
      function waitLeaflet(max = 8000) {
        return new Promise((resolve, reject) => {
          const t0 = Date.now();
          (function tick() {
            if (window.L && L.Map) return resolve(window.L);
            if (Date.now() - t0 > max) return reject(new Error('Leaflet failed to initialize'));
            setTimeout(tick, 25);
          })();
        });
      }

      // –ù–ï –≥—Ä—É–∑–∏–º –ª–æ–∫–∞–ª—å–Ω—ã–µ —Å–∫—Ä–∏–ø—Ç—ã ‚Äî —É –≤–∞—Å 404/ESM. –¢–æ–ª—å–∫–æ CDN-UMD.
      window.leafletPluginsReady = (async () => {
        await waitLeaflet();

        // side-by-side (UMD)
        let ok = await load('https://unpkg.com/leaflet-side-by-side@2.0.1/leaflet-side-by-side.min.js');
        if (!(ok && window.L && L.control && typeof L.control.sideBySide === 'function')) {
          ok = await load('https://cdn.jsdelivr.net/npm/leaflet-side-by-side@2.0.1/leaflet-side-by-side.min.js');
        }

        // textpath (UMD)
        await load('https://cdn.jsdelivr.net/npm/leaflet-textpath@1.2.3/leaflet.textpath.min.js');

        // –í–ê–ñ–ù–û: –ù–ï –∑–∞–≥—Ä—É–∂–∞—Ç—å /assets/leaflet-side-by-side.min.js (–ª–æ–º–∞–µ—Ç),
        // –ù–ï –∑–∞–≥—Ä—É–∂–∞—Ç—å /assets/leaflet.textpath.js (404),
        // –ù–ï –∑–∞–≥—Ä—É–∂–∞—Ç—å /assets/leaflet-rect-select.js (ESM —Å export).

        window.__Leaflet = window.L; // —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
        console.log('Leaflet ready?', !!(window.L && L.Map && L.Control && L.tileLayer), 'version:', window.L && L.version);
        return true;
      })();
    })();
  </script>



  <!-- Core libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="/assets/osmtogeojson.min.js"></script>

  <!-- XSS Prevention Utilities -->
  <script src="/assets/common-utils.js"></script>

  <!-- Chart.js + zoom -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2"></script>

  <!-- Leaflet plugins -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet-textpath@1.2.3/leaflet.textpath.min.js" defer></script>
  <link rel="stylesheet" href="/assets/leaflet-side-by-side-layout.css">

  <!-- Leaflet verification -->
  <script>
    (function(){
      const ok = !!(window.L && L.Map && L.Control && L.tileLayer);
      console.log('Leaflet ready?', ok, 'version:', window.L && L.version);
      if (!ok) throw new Error('Leaflet failed to initialize');
      window.__Leaflet = window.L;
    })();
  </script>

  <!-- Chart.js plugin registration -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      try {
        if (window['chartjs-plugin-zoom']) {
          Chart.register(window['chartjs-plugin-zoom']);
        }
      } catch(e) { console.warn('Chart zoom register failed:', e); }
    });
  </script>

  <!-- Styles -->
  <link rel="stylesheet" href="/assets/styles_ndvi.css" />
</head>

<body>
  <header id="site-header" class="header" role="banner" aria-label="–®–∞–ø–∫–∞ —Å–∞–π—Ç–∞"></header>

  <div class="container">
    <div class="sidebar">
      <div class="section">
        <h3>üìä NDVI –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ä–∞—Å—Ç–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏</h3>
        <p style="font-size:11px;color:#666;margin:5px 0;">
          –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –≤–µ–≥–µ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Å–µ–≤–æ–≤
        </p>

        <div class="date-range">
          <input type="date" id="start-date" value="2024-05-01" />
          <input type="date" id="end-date" value="2024-09-30" />
        </div>

        <div class="controls">
          <button id="load-ndvi">üîÑ –ó–∞–≥—Ä—É–∑–∏—Ç—å NDVI</button>
          <button id="show-zones">üó∫Ô∏è –ü–æ–∫–∞–∑–∞—Ç—å –∑–æ–Ω—ã</button>
          <button id="select-area">‚úèÔ∏è –í—ã–¥–µ–ª–∏—Ç—å –æ–±–ª–∞—Å—Ç—å</button>
          <button id="generate-report">üìë –û—Ç—á–µ—Ç</button>
        </div>

        <div id="selection-info" style="display:none;margin:10px 0;padding:8px;background:#e3f2fd;border-radius:4px;font-size:11px;">
          <strong>üìç –û–±–ª–∞—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∞</strong><br>
          <span id="selection-coords"></span><br>
          <button id="clear-selection" style="margin-top:5px;padding:4px 8px;font-size:10px;background:#dc3545;color:#fff;border:none;border-radius:3px;cursor:pointer;">
            –û—á–∏—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ
          </button>
        </div>

        <div class="ndvi-legend">
          <div class="ndvi-class water">–í–æ–¥–∞<br>&lt; 0</div>
          <div class="ndvi-class bare-soil">–ü–æ—á–≤–∞<br>0 - 0.2</div>
          <div class="ndvi-class sparse">–†–µ–¥–∫–∞—è<br>0.2 - 0.3</div>
          <div class="ndvi-class moderate">–°—Ä–µ–¥–Ω—è—è<br>0.3 - 0.6</div>
          <div class="ndvi-class dense">–ì—É—Å—Ç–∞—è<br>&gt; 0.6</div>
        </div>

        <div class="control-row" style="margin:8px 0">
          <label style="font-size:12px;display:flex;gap:8px;align-items:center">
            <input type="checkbox" id="auto-refresh" />
            –ê–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –∫–∞—Ä—Ç—ã
          </label>
        </div>
        
        <div id="error-container"></div>
      </div>

      <div class="section">
        <h3>üåæ –°–µ–ª—å—Å–∫–æ—Ö–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–æ–Ω—ã</h3>
        <div id="zones-list"></div>
      </div>

      <div class="section">
        <h3>üç© –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∫–ª–∞—Å—Å–∞–º NDVI</h3>
        <div style="height:160px"><canvas id="ndvi-pie"></canvas></div>
        <div id="ndvi-bins-table" style="margin-top:8px"></div>
      </div>

      <div class="section">
        <h3>üïì –í—Ä–µ–º–µ–Ω–Ω–∞—è –ª–µ–Ω—Ç–∞</h3>
        <div id="timeline-row" style="display:none;gap:8px;align-items:center">
          <input type="range" id="date-slider" min="0" max="0" value="0" style="flex:1" />
          <span id="date-label" style="font-size:12px;color:#555">‚Äî</span>
        </div>
        <div class="control-row" style="margin:8px 0">
          <label style="font-size:12px;">–°–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏: <span id="speed-value">1.0</span>—Å</label>
          <input type="range" id="animation-speed" min="100" max="3000" value="1000" step="100" style="width:100%" />
        </div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
          <button id="btn-animate">‚ñ∂Ô∏è –ê–Ω–∏–º–∞—Ü–∏—è</button>
          <button id="btn-export">‚¨áÔ∏è –≠–∫—Å–ø–æ—Ä—Ç CSV</button>
          <select id="compare-mode" style="font-size:12px">
            <option value="ends">–°—Ä–∞–≤–Ω–∏—Ç—å –Ω–∞—á–∞–ª–æ/–∫–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞</option>
            <option value="custom">–í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—ã‚Ä¶</option>
          </select>
          <button id="btn-compare">ü™ü –°—Ä–∞–≤–Ω–∏—Ç—å</button>
          <button id="btn-pin" class="muted">üìç –†–µ–∂–∏–º –ø–∏–Ω–æ–≤</button>
        </div>
      </div>

      <div class="section">
        <h3>üìå –°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Ç–æ—á–∫–∏</h3>
        <div id="pins"></div>
      </div>

      <div class="section">
        <h3>üìà –î–∏–Ω–∞–º–∏–∫–∞ NDVI</h3>
        <canvas id="ndvi-chart"></canvas>
      </div>

      <div class="section">
        <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
        <div class="stats-grid" id="stats"></div>
      </div>
    </div>

    <div class="main-content">
      <div class="loading" id="loading"><div class="spinner"></div></div>
      <div id="map"></div>
    </div>
  </div>

  <!-- –ì–ª–∞–≤–Ω—ã–π –º–æ–¥—É–ª—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è -->
  <script type="module">
    const Lf = (window.__Leaflet || window.L);
    if (!Lf || !Lf.Map || !Lf.Control || !Lf.tileLayer) {
      throw new Error('Leaflet API not ready inside module');
    }

    async function waitForLibraries() {
      const maxWait = 10000, t0 = Date.now();
      return new Promise((resolve) => {
        (function loop(){
          const ok = !!(window.turf && window.osmtogeojson && window.Chart);
          if (ok) {
            console.log('‚úÖ –í—Å–µ –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
            resolve();
          } else if (Date.now() - t0 > maxWait) {
            console.error('‚ùå Timeout –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –±–∏–±–ª–∏–æ—Ç–µ–∫:', {
              turf: !!window.turf, osmtogeojson: !!window.osmtogeojson, Chart: !!window.Chart
            });
            alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.');
            resolve();
          } else {
            setTimeout(loop, 100);
          }
        })();
      });
    }

    import {
      fetchJSON, debounce,
      getNDVIColor, textColor, tpl, showError, showProgress, NoDataError, APIError
    } from "/assets/ndvi-utils.js";

    import { RectSelector } from "/assets/leaflet-rect-select.js";

    import {
      renderNDVIPie, buildNDVIChart, exportCSV, setupTimelineSlider,
      runAnimation, Pins, attachPointInspector, buildSideBySide
    } from "/assets/ndvi-ui.js";

    // ===== Overpass helper —Å —Ñ–æ–ª–ª–±—ç–∫–∞–º–∏ =====
    async function fetchOverpass(query, options = {}) {
      const { showLoading = true, timeout = 30000 } = options;

      const endpoints = [
        "https://overpass-api.de/api/interpreter",
        "https://z.overpass-api.de/api/interpreter",
        "https://overpass.kumi.systems/api/interpreter"
      ];

      // Show loading indicator
      let loadingEl = null;
      if (showLoading) {
        loadingEl = document.createElement('div');
        loadingEl.id = 'overpass-loading';
        loadingEl.innerHTML = `
          <div style="position:fixed;top:70px;right:20px;background:rgba(0,123,255,0.95);color:#fff;padding:12px 16px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:10000;font-size:13px;display:flex;align-items:center;gap:10px;">
            <div class="spinner" style="border:2px solid rgba(255,255,255,0.3);border-top:2px solid #fff;border-radius:50%;width:16px;height:16px;animation:spin 0.8s linear infinite;"></div>
            <span>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö OpenStreetMap...</span>
          </div>
        `;
        document.body.appendChild(loadingEl);
      }

      try {
        let lastErr;
        for (let i = 0; i < endpoints.length; i++) {
          const url = endpoints[i];
          try {
            // Create abort controller for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            const resp = await fetch(url, {
              method: "POST",
              headers: { "Content-Type":"application/x-www-form-urlencoded; charset=UTF-8" },
              body: "data=" + encodeURIComponent(query),
              signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!resp.ok) throw new Error("Overpass HTTP " + resp.status);

            const data = await resp.json();
            return data;
          } catch (e) {
            const isLastEndpoint = i === endpoints.length - 1;
            console.warn(`Overpass endpoint failed (${i + 1}/${endpoints.length}):`, url, e.message);
            lastErr = e;

            // Update loading message for retries
            if (loadingEl && !isLastEndpoint) {
              const msgEl = loadingEl.querySelector('span');
              if (msgEl) {
                msgEl.textContent = `–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ (${i + 2}/${endpoints.length})...`;
              }
            }
          }
        }
        throw lastErr || new Error("All Overpass endpoints failed");
      } finally {
        // Remove loading indicator
        if (loadingEl && loadingEl.parentNode) {
          loadingEl.parentNode.removeChild(loadingEl);
        }
      }
    }

    Promise.all([
      new Promise(r => (document.readyState === 'loading') ? document.addEventListener('DOMContentLoaded', r) : r()),
      waitForLibraries()
    ]).then(() => {
      console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è NDVI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
      window.ndviApp = new NDVIMonitoring();
    }).catch(err => {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', err);
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
    });

    class NDVIMonitoring {
      constructor() {
        this.API_BASE = location.origin + "/api/v1";
        // bbox –ê–∫–º–æ–ª–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏ –Ω–∞ –≤—Å—è–∫–∏–π
        this.bbox = [65.0,49.5,76.0,54.0];

        this.map = null;
        this.layers = {};
        this.ndviData = null;
        this.regionPolygon = null;
        this.useOSMForClip = true;

        this.pins = new Pins();
        this.detachInspector = null;
        this.detachCompare = null;

        this.init();
      }

      async init() {
        this.initMap();
        this.initUI();
        this.loadZones();

        try {
          await this.loadOSMBoundary();   // –ì—Ä–∞–Ω–∏—Ü–∞ –æ–±–ª–∞—Å—Ç–∏ (OSM)
          await this.loadOSMDistricts();  // –†–∞–π–æ–Ω—ã –æ–±–ª–∞—Å—Ç–∏ (OSM)
        } catch(e) {
          console.warn("OSM layers failed:", e);
          this.useOSMForClip = false;
        }
      }

      initMap() {
        this.map = Lf.map("map", { center:[51.16,71.45], zoom:7, zoomControl:true });

        // –æ—Ç–¥–µ–ª—å–Ω–∞—è ¬´–ø–ª–æ—Å–∫–æ—Å—Ç—å¬ª –¥–ª—è NDVI —Ç–∞–π–ª–æ–≤ –ø–æ–≤–µ—Ä—Ö –±–∞–∑–æ–≤–æ–π –∫–∞—Ä—Ç—ã
        this.map.createPane('ndvi');
        this.map.getPane('ndvi').style.zIndex = 450;   // –≤—ã—à–µ tilePane (200) –∏ overlayPane (400)
        this.map.getPane('ndvi').style.pointerEvents = 'none'; // –∫–ª–∏–∫–∏ –ø—Ä–æ—Ö–æ–¥—è—Ç –∫ –∫–∞—Ä—Ç–µ

        this.map.on('baselayerchange', () => {
          // –ø–æ–¥–Ω–∏–º–∞–µ–º –≤—Å–µ NDVI-—Ç–∞–π–ª—ã –Ω–∞–≤–µ—Ä—Ö, –µ—Å–ª–∏ Leaflet –≤–¥—Ä—É–≥ –ø–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–∏–ª —Å–ª–æ–∏
          this.layers.ndvi.eachLayer(l => l.bringToFront?.());
        });



        const osm = Lf.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom:19, attribution:"¬© OpenStreetMap"
        }).addTo(this.map);

        const sat = Lf.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
          maxZoom:19, attribution:"¬© Esri"
        });

        this.layers.osmRegion  = Lf.layerGroup().addTo(this.map);
        this.layers.districts  = Lf.layerGroup().addTo(this.map);
        this.layers.zones      = Lf.layerGroup().addTo(this.map);
        this.layers.ndvi       = Lf.layerGroup().addTo(this.map);

        Lf.control.layers(
          { "–ö–∞—Ä—Ç–∞":osm, "–°–ø—É—Ç–Ω–∏–∫":sat },
          {
            "–ì—Ä–∞–Ω–∏—Ü–∞ (OSM)": this.layers.osmRegion,
            "–†–∞–π–æ–Ω—ã (OSM)": this.layers.districts,
            "–°/—Ö –∑–æ–Ω—ã": this.layers.zones,
            "NDVI —Å–ª–æ–π": this.layers.ndvi
          },
          { collapsed:true }
        ).addTo(this.map);

        const autoReload = debounce(() => {
          if (document.getElementById("auto-refresh")?.checked) this.loadNDVI();
        }, 2000);
        this.map.on("moveend", autoReload);
      }

      initUI() {
        this.pins.renderList(document.getElementById("pins"), this.map, this.getApiCtx());

        document.getElementById("load-ndvi").onclick = () => this.loadNDVI();
        document.getElementById("show-zones").onclick = () => this.toggleZones();
        document.getElementById("generate-report").onclick = () => this.generateReport();

        const selector = new RectSelector(this.map, {
          onSelect: (bounds) => {
            this.selectedBounds = bounds;
            const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
            document.getElementById("selection-coords").textContent =
              `SW: ${sw.lat.toFixed(4)}, ${sw.lng.toFixed(4)} | NE: ${ne.lat.toFixed(4)}, ${ne.lng.toFixed(4)}`;
            document.getElementById("selection-info").style.display = "block";
            if (document.getElementById("auto-refresh")?.checked) this.loadNDVI();
          }
        });

        document.getElementById("select-area").onclick = (e) => {
          const btn = e.currentTarget;
          if (!selector.active) {
            selector.enable();
            btn.style.background = "#28a745"; btn.style.color = "#fff"; btn.textContent = "‚úì –†–µ–∂–∏–º –≤—ã–¥–µ–ª–µ–Ω–∏—è";
          } else {
            selector.disable();
            btn.style.background = ""; btn.style.color = ""; btn.textContent = "‚úèÔ∏è –í—ã–¥–µ–ª–∏—Ç—å –æ–±–ª–∞—Å—Ç—å";
          }
        };

        document.getElementById("clear-selection").onclick = () => {
          selector.clear(); this.selectedBounds = null;
          document.getElementById("selection-info").style.display = "none";
          if (document.getElementById("auto-refresh")?.checked) this.loadNDVI();
        };

        document.getElementById("animation-speed")?.addEventListener("input", (e) => {
          document.getElementById("speed-value").textContent = (e.target.value / 1000).toFixed(1);
        });

        document.getElementById("btn-animate").onclick = () => {
          const tl = this.ndviData?.timeline || [];
          if (!tl.length) { 
            showError(document.getElementById("error-container"), "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏", "info");
            return; 
          }

          let paused = false;
          let index = 0;

          runAnimation({
            btnEl: document.getElementById("btn-animate"),
            timeline: tl,
            onTick: async (i, row) => {
              if (paused) return;
              try {
                await this.visualizeNDVIOnMap(row.date);
                document.getElementById("date-slider").value = i;
                const delay = parseInt(document.getElementById("animation-speed")?.value || 1000);
                await new Promise(resolve => setTimeout(resolve, delay));
              } catch (e) {
                console.error("Animation frame error:", e);
                if (e?.status >= 500 || String(e?.message||"").includes("HTTP 5")) {
                  paused = true;
                  showError(document.getElementById("error-container"), 
                    "NDVI —Å–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (5xx). –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –Ω–∞ –ø–∞—É–∑—É.", "warning");
                }
              }
            },
            getIndex: () => index,
            setIndex: (v) => { index = v; }
          });
        };

        document.getElementById("btn-compare").onclick = async () => {
          const tl = this.ndviData?.timeline || [];
          if (!tl.length) { 
            showError(document.getElementById("error-container"), "–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ NDVI –¥–∞–Ω–Ω—ã–µ", "info");
            return; 
          }
          
          if (this.detachCompare) { 
            this.detachCompare(); 
            this.detachCompare = null; 
            return; 
          }

          const mode = document.getElementById("compare-mode").value;
          let d1 = tl[0].date, d2 = tl.at(-1).date;
          
          if (mode === "custom") {
            d1 = prompt("–ü–µ—Ä–≤–∞—è –¥–∞—Ç–∞ (YYYY-MM-DD):", d1) || d1;
            d2 = prompt("–í—Ç–æ—Ä–∞—è –¥–∞—Ç–∞ (YYYY-MM-DD):", d2) || d2;
          }
          
          try {
            this.detachCompare = await buildSideBySide({
              map: this.map, apiBase: this.API_BASE, bbox: this.mapBboxForBackend(), dateA: d1, dateB: d2
            });
          } catch (e) {
            console.error("Side-by-side error:", e);
            showError(document.getElementById("error-container"), 
              "–û—à–∏–±–∫–∞ —Ä–µ–∂–∏–º–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.", "error");
          }
        };

        document.getElementById("btn-export").onclick = () => {
          const tl = this.ndviData?.timeline || [];
          if (!tl.length) {
            showError(document.getElementById("error-container"), "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞", "info");
            return;
          }
          exportCSV(tl);
        };

        document.getElementById("btn-pin").onclick = (e) => {
          this.map._pinning = !this.map._pinning;
          e.currentTarget.classList.toggle("muted", !this.map._pinning);
          this.map.getContainer().style.cursor = this.map._pinning ? "cell" : "";
        };
      }

      mapBboxForBackend() {
        if (this.selectedBounds) {
          const sw = this.selectedBounds.getSouthWest(), ne = this.selectedBounds.getNorthEast();
          return [sw.lng, sw.lat, ne.lng, ne.lat];
        }
        const b = this.map.getBounds();
        return [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()];
      }

      async loadZones() {
        try {
          const data = await fetchJSON(`${this.API_BASE}/ndvi/zones?bbox=${this.bbox.join(",")}`, {
            maxRetries: 1
          });
          this.zones = Array.isArray(data) ? data : (data.zones || []);
        } catch {
          this.zones = [
            { name:"–°–µ–≤–µ—Ä–Ω–∞—è –∑–æ–Ω–∞", description:"–û—Å–Ω–æ–≤–Ω–∞—è –∑–µ—Ä–Ω–æ–≤–∞—è –∑–æ–Ω–∞", center:[52.28,70.4], area_ha:1200000, typical_crops:["–ü—à–µ–Ω–∏—Ü–∞","–Ø—á–º–µ–Ω—å"] },
            { name:"–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞", description:"–°–º–µ—à–∞–Ω–Ω–æ–µ –∑–µ–º–ª–µ–¥–µ–ª–∏–µ", center:[51.16,71.45], area_ha:950000, typical_crops:["–ü—à–µ–Ω–∏—Ü–∞","–ü–æ–¥—Å–æ–ª–Ω–µ—á–Ω–∏–∫","–õ—ë–Ω"] },
            { name:"–Æ–∂–Ω–∞—è –∑–æ–Ω–∞", description:"–û—Ä–æ—à–∞–µ–º–æ–µ –∑–µ–º–ª–µ–¥–µ–ª–∏–µ", center:[50.4,72.3], area_ha:780000, typical_crops:["–ö—É–∫—É—Ä—É–∑–∞","–û–≤–æ—â–∏"] }
          ];
        }
        
        const container = document.getElementById("zones-list");
        container.innerHTML = "";

        (this.zones||[]).forEach(zone => {
          const div = document.createElement("div");
          div.className = "zone-item";

          // Safe HTML construction using escapeHtml to prevent XSS
          const safeName = escapeHtml(zone.name);
          const safeDescription = escapeHtml(zone.description);
          const safeArea = sanitizeNumber(zone.area_ha / 1000, 0);
          const safeCrops = sanitizeArray(zone.typical_crops);

          div.innerHTML = `
            <strong>${safeName}</strong><br>
            <small>${safeDescription}</small><br>
            <small>–ü–ª–æ—â–∞–¥—å: ${safeArea} —Ç—ã—Å. –≥–∞</small><br>
            <small>–ö—É–ª—å—Ç—É—Ä—ã: ${safeCrops}</small>`;
          div.onclick = () => {
            this.map.setView(zone.center, 9);
            div.classList.add("active");
            setTimeout(()=>div.classList.remove("active"), 2000);
          };
          container.appendChild(div);
        });
      }

      toggleZones() {
        const g = this.layers.zones; 
        const has = g.getLayers().length > 0;
        if (has) { g.clearLayers(); return; }
        
        g.clearLayers();
        (this.zones||[]).forEach(zone => {
          // Safe HTML for popup to prevent XSS
          const safeName = escapeHtml(zone.name);
          const safeDescription = escapeHtml(zone.description);
          const safeArea = sanitizeNumber(zone.area_ha / 1000, 0);
          const safeCrops = sanitizeArray(zone.typical_crops);

          Lf.circleMarker(zone.center, {
            radius: Math.sqrt(zone.area_ha/1000)*2,
            color:"#007cba",
            fillColor:"#007cba",
            fillOpacity:.3,
            weight:2
          }).bindPopup(
            `<div class="popup-content">
              <h4>${safeName}</h4>
              <div class="info-row">üìç –ü–ª–æ—â–∞–¥—å: ${safeArea} —Ç—ã—Å. –≥–∞</div>
              <div class="info-row">üåæ –ö—É–ª—å—Ç—É—Ä—ã: ${safeCrops}</div>
              <div class="info-row">${safeDescription}</div>
            </div>`
          ).addTo(g);
        });
      }

      async loadNDVI() {
        const errorContainer = document.getElementById("error-container");
        errorContainer.innerHTML = ""; 
        
        const loadingEl = document.getElementById("loading");
        loadingEl.classList.add("active");
        
        const start = document.getElementById("start-date").value;
        const end = document.getElementById("end-date").value;
        
        try {
          const bbox = this.mapBboxForBackend();
          const url = `${this.API_BASE}/ndvi/statistics?bbox=${bbox.join(",")}&start=${start}&end=${end}`;
          
          const data = await fetchJSON(url, { maxRetries: 2, retryDelay: 3000 });
          
          if (data.status !== "success") {
            throw new Error("Statistics API returned non-success status");
          }
          
          this.ndviData = data;

          this.renderStats();
          buildNDVIChart({ canvas: document.getElementById("ndvi-chart"), timeline: data.timeline });

          await renderNDVIPie({ 
            apiBase:this.API_BASE, 
            bbox, 
            start, 
            end, 
            pieCanvas: document.getElementById("ndvi-pie"), 
            tableContainer: document.getElementById("ndvi-bins-table") 
          });

          await this.visualizeNDVIOnMap();

          setupTimelineSlider({
            rowEl: document.getElementById("timeline-row"),
            sliderEl: document.getElementById("date-slider"),
            labelEl: document.getElementById("date-label"),
            timeline: data.timeline,
            onChange: async (_i,row) => {
              try { 
                await this.visualizeNDVIOnMap(row.date); 
              } catch(e){ 
                console.error("Slider change error:", e); 
              }
            }
          });
          
        } catch (e) {
          console.error("loadNDVI error:", e);
          
          if (e instanceof NoDataError) {
            showError(errorContainer, 
              "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ø—É—Ç–Ω–∏–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞ –∏ –æ–±–ª–∞—Å—Ç–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç –∏–ª–∏ —É–º–µ–Ω—å—à–∏—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –æ–±–ª–∞—á–Ω–æ—Å—Ç—å.",
              "warning"
            );
          } else if (e instanceof APIError && e.status >= 500) {
            showError(errorContainer, 
              "–°–µ—Ä–≤–∏—Å NDVI –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
              "error"
            );
          } else {
            showError(errorContainer,
              "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å NDVI –¥–∞–Ω–Ω—ã–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å API.",
              "error"
            );
          }
        } finally {
          loadingEl.classList.remove("active");
        }
      }

      async visualizeNDVIOnMap(dateOverride = null) {
        this.layers.ndvi.clearLayers();
        if (this.detachInspector) { 
          this.detachInspector(); 
          this.detachInspector = null; 
        }

        if (!Lf || typeof Lf.tileLayer !== 'function') {
          throw new Error('Leaflet API not ready: tileLayer missing');
        }

        const bbox  = this.mapBboxForBackend();
        const start = dateOverride || document.getElementById("start-date").value;
        const end   = dateOverride || document.getElementById("end-date").value;
        
        if (!start || !end) throw new Error('Dates are empty');

        let resp;
        try {
          const url = `${this.API_BASE}/ndvi/geotiff?bbox=${bbox.join(",")}&start=${start}&end=${end}`;
          resp = await fetchJSON(url, { maxRetries: 1 });
        } catch (e) { 
          throw e; 
        }

        let tiffUrl = null;
        if (resp instanceof Blob) tiffUrl = URL.createObjectURL(resp);
        else if (typeof resp === 'string') tiffUrl = resp;
        else if (resp && typeof resp === 'object' && resp.tiff_url) tiffUrl = resp.tiff_url;

        if (!tiffUrl) throw new Error('NDVI endpoint returned no tiff_url/data');



        const tileUrl =
          `/titiler/cog/tiles/{z}/{x}/{y}?` +
          `url=${encodeURIComponent(tiffUrl)}&bidx=1&rescale=-0.2,1&colormap_name=rdylgn&return_mask=true`;

        Lf.tileLayer(tileUrl, {
          pane: 'ndvi',
          opacity: .95,
          attribution: "¬© Copernicus NDVI",
          maxZoom: 18,
          tileSize: 256
        }).addTo(this.layers.ndvi);


        this.detachInspector = await attachPointInspector({
          map: this.map, tiffUrl, start, end, apiBase:this.API_BASE, bbox, pins: this.pins
        });

        this.pins.renderList(document.getElementById("pins"), this.map, this.getApiCtx());
      }

      renderStats() {
        const s = this.ndviData.statistics || {};
        const timeline = this.ndviData.timeline || [];
        
        let html = `
          <div class="stat-item">
            <div class="stat-value">${(s.mean_ndvi??0).toFixed(3)}</div>
            <div class="stat-label">–°—Ä–µ–¥–Ω–∏–π NDVI</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${(s.median_ndvi??0).toFixed(3)}</div>
            <div class="stat-label">–ú–µ–¥–∏–∞–Ω–∞ NDVI</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${s.total_observations||0}</div>
            <div class="stat-label">–ù–∞–±–ª—é–¥–µ–Ω–∏–π</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${this.ndviData.products_available||0}</div>
            <div class="stat-label">–°–Ω–∏–º–∫–æ–≤</div>
          </div>`;

        const t = s.trend;
        if (t && t.direction !== "insufficient_data") {
          const arrow = t.direction === "increasing" ? "‚Üó" : t.direction === "decreasing" ? "‚Üò" : "‚Üí";
          const color = t.direction === "increasing" ? "#28a745" : t.direction === "decreasing" ? "#dc3545" : "#6c757d";
          html += `
            <div class="stat-item">
              <div class="stat-value" style="color:${color}">${arrow} ${t.direction}</div>
              <div class="stat-label">–¢—Ä–µ–Ω–¥ (R¬≤: ${t.r_squared})</div>
            </div>`;
        }
        
        const status = s.status;
        if (status) {
          const colors = { 
            optimal:"#28a745", high:"#007cba", low:"#ffc107", 
            critical_low:"#dc3545", water:"#0066cc", bare_soil:"#8b4513" 
          };
          const c = colors[status.status] || "#6c757d";
          html += `
            <div class="stat-item" style="grid-column:1/-1;">
              <div class="stat-value" style="background:${c};color:white;padding:8px;border-radius:4px;">
                ${status.level.toUpperCase()}
              </div>
              <div class="stat-label">${status.description}</div>
            </div>`;
        }
        
        if (timeline.length > 0 && timeline[timeline.length - 1].percentiles) {
          const perc = timeline[timeline.length - 1].percentiles;
          html += `
            <div class="stat-item" style="grid-column:1/-1;font-size:10px;background:#f8f9fa;padding:8px;border-radius:4px;">
              <div style="font-weight:bold;margin-bottom:4px;color:#666;">–ü–µ—Ä—Ü–µ–Ω—Ç–∏–ª–∏ (–ø–æ—Å–ª–µ–¥–Ω—è—è –¥–∞—Ç–∞):</div>
              <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;text-align:center;">
                <div><div style="color:#999">P10</div><div style="font-weight:bold">${perc.p10?.toFixed(3)||'‚Äî'}</div></div>
                <div><div style="color:#999">P25</div><div style="font-weight:bold">${perc.p25?.toFixed(3)||'‚Äî'}</div></div>
                <div><div style="color:#999">P50</div><div style="font-weight:bold">${perc.p50?.toFixed(3)||'‚Äî'}</div></div>
                <div><div style="color:#999">P75</div><div style="font-weight:bold">${perc.p75?.toFixed(3)||'‚Äî'}</div></div>
                <div><div style="color:#999">P90</div><div style="font-weight:bold">${perc.p90?.toFixed(3)||'‚Äî'}</div></div>
              </div>
            </div>`;
        }
        
        document.getElementById("stats").innerHTML = html;
      }

      // ===== OSM: –≥—Ä–∞–Ω–∏—Ü–∞ –æ–±–ª–∞—Å—Ç–∏ (admin_level=4) =====
      async loadOSMBoundary() {
        const query = `
          [out:json][timeout:60];
          (
            area["name:en"="Akmola Region"];
            area["name"="Aqmola Region"];
            area["name"="–ê–∫–º–æ–ª–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å"];
          )->.reg;
          (
            relation["boundary"="administrative"]["admin_level"="4"](area.reg);
          );
          out geom;`;
        
        const osmJson = await fetchOverpass(query);
        const gj = osmtogeojson(osmJson);
        const feats = (gj.type === "FeatureCollection") ? gj.features : [gj];

        // –±–µ—Ä—ë–º —Å–∞–º—ã–π –∫—Ä—É–ø–Ω—ã–π –ø–æ–ª–∏–≥–æ–Ω –Ω–∞ –≤—Å—è–∫–∏–π
        let best=null, bestArea=-1;
        for (const f of feats){ 
          if(!f.geometry) continue; 
          try{ const a=turf.area(f); if(a>bestArea){bestArea=a; best=f;} }catch{} 
        }
        if (!best) throw new Error("OSM boundary not found");

        this.layers.osmRegion.clearLayers();
        const osmGeo = Lf.geoJSON(best, {
          style:{ color:"#7c3aed", weight:3, fillOpacity:.10, dashArray:"4,3" },
          onEachFeature: (f,layer) => layer.bindTooltip(
            f.properties?.name || "OSM –≥—Ä–∞–Ω–∏—Ü–∞ –ê–∫–º–æ–ª–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
            { permanent:false, direction:"auto", className:"region-label" }
          )
        }).addTo(this.layers.osmRegion);

        const bounds = osmGeo.getBounds();
        if (bounds.isValid()) this.map.fitBounds(bounds, { padding:[20,20] });

        this.regionPolygon = (best.geometry.type === "Polygon")
          ? turf.polygon(best.geometry.coordinates)
          : turf.multiPolygon(best.geometry.coordinates);
      }

      // ===== OSM: —Ä–∞–π–æ–Ω—ã –æ–±–ª–∞—Å—Ç–∏ (admin_level=6) =====
      async loadOSMDistricts() {
        const query = `
          [out:json][timeout:60];
          (
            area["name:en"="Akmola Region"];
            area["name"="Aqmola Region"];
            area["name"="–ê–∫–º–æ–ª–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å"];
          )->.reg;
          (
            relation["boundary"="administrative"]["admin_level"="6"](area.reg);
          );
          out geom;`;

        const osmJson = await fetchOverpass(query);
        const gj = osmtogeojson(osmJson);
        const feats = (gj.type === "FeatureCollection") ? gj.features : [gj];
        if (!feats.length) {
          console.warn("No OSM districts found (admin_level=6)");
          return;
        }

        this.layers.districts.clearLayers();
        const fc = { type:"FeatureCollection", features:feats };

        Lf.geoJSON(fc, {
          style:{ color:"#1d4ed8", weight:1.5, fillOpacity:.05 },
          onEachFeature:(f,layer) => {
            const name = f.properties?.["name:ru"] || f.properties?.["name:kk"] || f.properties?.name || "–†–∞–π–æ–Ω";
            layer.bindTooltip(name, { permanent:false, direction:"auto", className:"district-label" });

            // –∞–∫–∫—É—Ä–∞—Ç–Ω–∞—è —Ç–µ–∫—Å—Ç–æ–≤–∞—è –ø–æ–¥–ø–∏—Å—å –ø–æ –ª–∏–Ω–∏–∏ (–µ—Å–ª–∏ textpath –ø–æ–¥—Ö–≤–∞—Ç–∏–ª—Å—è)
            try {
              if (layer instanceof L.Polygon || layer instanceof L.MultiPolygon) {
                const center = layer.getBounds().getCenter();
                layer.bindPopup(`<div class="popup-content"><strong>${name}</strong></div>`);
                // –ú–æ–∂–Ω–æ –¥–æ—Ä–∏—Å–æ–≤–∞—Ç—å –º–∞—Ä–∫–µ—Ä-–ª–µ–π–±–ª:
                Lf.circleMarker(center, { radius: 2, weight:0, fillOpacity:0 }).addTo(this.layers.districts)
                  .bindTooltip(name, { permanent:false, direction:"top", className:"district-label" });
              }
            } catch {}
          }
        }).addTo(this.layers.districts);
      }

      async generateReport() {
        const errorContainer = document.getElementById("error-container");
        const loadingEl = document.getElementById("loading");
        
        loadingEl.classList.add("active");
        
        const end = document.getElementById("end-date").value;
        
        try {
          const bbox = this.mapBboxForBackend();
          const areaType = this.selectedBounds ? "–≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏" : "—Ç–µ–∫—É—â–µ–π –æ–±–ª–∞—Å—Ç–∏ –∫–∞—Ä—Ç—ã";
          
          const url = `${this.API_BASE}/ndvi/report?bbox=${bbox.join(",")}&date=${end}`;
          const report = await fetchJSON(url, { maxRetries: 1 });
          
          report._areaType = areaType;
          
          Lf.popup({ maxWidth:420, maxHeight:520 })
            .setLatLng(this.map.getCenter())
            .setContent(tpl.report(report))
            .openOn(this.map);
            
        } catch (e) {
          console.error("Report generation error:", e);
          
          if (e instanceof NoDataError) {
            showError(errorContainer, 
              "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á—ë—Ç–∞ –∑–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥",
              "warning"
            );
          } else {
            showError(errorContainer, 
              "–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á—ë—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
              "error"
            );
          }
        } finally {
          loadingEl.classList.remove("active");
        }
      }

      getApiCtx() {
        return {
          apiBase: this.API_BASE,
          bbox: this.mapBboxForBackend(),
          start: document.getElementById("start-date").value,
          end:   document.getElementById("end-date").value
        };
      }
    }
  </script>


  <!-- –ú–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ header -->
  <script>
    (function () {
      async function mountHeader() {
        const url = document.body?.dataset?.headerUrl || '/header';
        try {
          const resp = await fetch(url, { cache: 'no-cache' });
          if (!resp.ok) throw new Error('Header HTTP ' + resp.status + ' (' + url + ')');
          const html = await resp.text();

          const el = document.getElementById('site-header');
          if (!el) throw new Error('#site-header not found');

          el.innerHTML = html;

          el.querySelectorAll('script').forEach(old => {
            const s = document.createElement('script');
            [...old.attributes].forEach(a => s.setAttribute(a.name, a.value));
            if (old.src) { s.async = false; } else { s.textContent = old.textContent || ''; }
            old.replaceWith(s);
          });

          initHeaderInteractions?.();
          highlightActiveLink?.();
          updateStatusBadge?.();
          wireHeaderButtons?.();
        } catch (e) {
          console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å header:', e);
          const el = document.getElementById('site-header');
          if (el && !el.innerHTML.trim()) {
            el.innerHTML = '<div class="alert warning">–•–µ–¥–µ—Ä –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è</div>';
          }
        }
      }

      function highlightActiveLink() {
        const current = location.pathname.replace(/\/+$/, '/') || '/';
        document.querySelectorAll('#site-header .nav-link[href], #site-header .dropdown-item[href]').forEach(a => {
          const href = new URL(a.href, location.origin).pathname.replace(/\/+$/, '/') || '/';
          if (href === current) a.classList.add('active');
        });
      }

      function initHeaderInteractions() {
        document.querySelectorAll('#site-header .nav-item.has-dropdown > .nav-link').forEach(btn => {
          btn.addEventListener('click', () => {
            const expanded = btn.getAttribute('aria-expanded') === 'true';
            btn.setAttribute('aria-expanded', String(!expanded));
            btn.parentElement.classList.toggle('open', !expanded);
          });
          btn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
          });
        });
      }

      function updateStatusBadge() {
        const badge = document.querySelector('#site-header #status-badge');
        if (!badge) return;
        fetch('/api/v1/settings/health')
          .then(r => r.json())
          .then(data => {
            if (data.ok) { 
              badge.textContent = '–û–Ω–ª–∞–π–Ω'; 
              badge.className = 'status-badge'; 
            } else if (data.cdse_ok) { 
              badge.textContent = '–ß–∞—Å—Ç–∏—á–Ω–æ'; 
              badge.className = 'status-badge warning'; 
            } else { 
              badge.textContent = '–û—à–∏–±–∫–∞'; 
              badge.className = 'status-badge error'; 
            }
          })
          .catch(() => { 
            badge.textContent = '–û—Ñ—Ñ–ª–∞–π–Ω'; 
            badge.className = 'status-badge error'; 
          });
      }

      function wireHeaderButtons() {
        document.querySelector('#site-header #btn-refresh')?.addEventListener('click', () => location.reload());
      }

      document.addEventListener('DOMContentLoaded', () => { mountHeader(); });
    })();
  </script>

  <!-- Global Error Boundary -->
  <script>
    (function() {
      // Container for global error notifications
      let errorNotificationDiv = null;

      function showGlobalError(message, level = 'error') {
        if (!errorNotificationDiv) {
          errorNotificationDiv = document.createElement('div');
          errorNotificationDiv.id = 'global-error-notification';
          errorNotificationDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 400px;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-size: 14px;
            line-height: 1.5;
            animation: slideIn 0.3s ease-out;
          `;
          document.body.appendChild(errorNotificationDiv);
        }

        // Set color based on level
        const colors = {
          error: { bg: '#fee', border: '#c33', text: '#c33' },
          warning: { bg: '#fff3cd', border: '#ffc107', text: '#856404' },
          info: { bg: '#d1ecf1', border: '#17a2b8', text: '#0c5460' }
        };
        const color = colors[level] || colors.error;

        errorNotificationDiv.style.backgroundColor = color.bg;
        errorNotificationDiv.style.borderLeft = `4px solid ${color.border}`;
        errorNotificationDiv.style.color = color.text;
        errorNotificationDiv.textContent = message;

        // Auto-hide after 8 seconds
        setTimeout(() => {
          if (errorNotificationDiv) {
            errorNotificationDiv.style.opacity = '0';
            setTimeout(() => {
              if (errorNotificationDiv && errorNotificationDiv.parentNode) {
                errorNotificationDiv.parentNode.removeChild(errorNotificationDiv);
                errorNotificationDiv = null;
              }
            }, 300);
          }
        }, 8000);
      }

      // Add animations
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(400px); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
      `;
      document.head.appendChild(style);

      // Global error handler for uncaught errors
      window.addEventListener('error', (event) => {
        console.error('Uncaught error:', event.error);
        const message = event.error?.message || 'An unexpected error occurred';
        showGlobalError(`Error: ${message}. Please refresh the page.`, 'error');
      });

      // Global handler for unhandled promise rejections
      window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
        const message = event.reason?.message || event.reason || 'Promise rejection';
        showGlobalError(`Async Error: ${message}. Please try again.`, 'error');
        event.preventDefault(); // Prevent default browser handling
      });

      console.log('‚úÖ Global error boundary initialized');
    })();
  </script>
</body>
</html>